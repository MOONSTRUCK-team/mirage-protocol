type Nat = nat;
type Principal = principal;

type TransferError = variant {
  Unauthorized: record { token_ids: vec Nat };
  TokenAlreadyExists: record { token_id: Nat };
  TokenNotFound: record { token_id: Nat };
  InsufficientBalance: record { token_id: Nat };
  InvalidMetadata: record { token_id: Nat };
};

type TransferResult = variant {
  Ok: Nat;
  Err: TransferError;
};

type MetadataEntry = record {
  key: text;
  value: text;
};

type MintArgs = record {
  to: record {
    owner: Principal;
    subaccount: opt blob;
  };
  token_id: Nat;
  metadata: vec MetadataEntry;
};

type TransferArgs = record {
  from: record {
    owner: Principal;
    subaccount: opt blob;
  };
  to: record {
    owner: Principal;
    subaccount: opt blob;
  };
  token_ids: vec Nat;
};

type NFTCollection = record {
  name: text;
  symbol: text;
  contract_address: Principal;
};

service : {
  create_nft_collection: (text, text) -> (Principal);
  mint_token_in_collection: (nat, MintArgs) -> (variant { Ok: Nat; Err: TransferError });
  transfer_tokens_in_collection: (nat, vec TransferArgs) -> (vec opt TransferResult);
  burn_token_in_collection: (nat, Nat) -> (variant { Ok: Nat; Err: TransferError });
  get_all_collections: () -> (vec NFTCollection) query;
}
